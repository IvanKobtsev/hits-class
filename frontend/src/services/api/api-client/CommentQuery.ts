//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './CommentClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type GetAssignmentCommentsCommentQueryParameters = {
  assignmentId: number ;
}

export type AddCommentToAssignmentCommentQueryParameters = {
  assignmentId: number ;
}

export type GetPublicationCommentsCommentQueryParameters = {
  publicationId: number ;
}

export type AddCommentToPublicationCommentQueryParameters = {
  publicationId: number ;
}

export type EditCommentCommentQueryParameters = {
  commentId: number ;
}

export type DeleteCommentCommentQueryParameters = {
  commentId: number ;
}

export function getAssignmentCommentsUrl(assignmentId: number): string {
  let url_ = getBaseUrl() + "/api/assignments/{assignmentId}/comments";
if (assignmentId === undefined || assignmentId === null)
  throw new Error("The parameter 'assignmentId' must be defined.");
url_ = url_.replace("{assignmentId}", encodeURIComponent("" + assignmentId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getAssignmentCommentsDefaultOptions: Omit<UseQueryOptions<Types.PagedResultOfCommentDto, unknown, Types.PagedResultOfCommentDto>, 'queryKey'> = {
  queryFn: __getAssignmentComments,
};
export function getGetAssignmentCommentsDefaultOptions() {
  return getAssignmentCommentsDefaultOptions;
};
export function setGetAssignmentCommentsDefaultOptions(options: typeof getAssignmentCommentsDefaultOptions) {
  getAssignmentCommentsDefaultOptions = options;
}

export function getAssignmentCommentsQueryKey(assignmentId: number): QueryKey;
export function getAssignmentCommentsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { assignmentId,  } = params[0] as GetAssignmentCommentsCommentQueryParameters;

    return trimArrayEnd([
        'CommentClient',
        'getAssignmentComments',
        assignmentId as any,
      ]);
  } else {
    return trimArrayEnd([
        'CommentClient',
        'getAssignmentComments',
        ...params
      ]);
  }
}
function __getAssignmentComments(context: QueryFunctionContext) {
  return Client.getAssignmentComments(
      context.queryKey[2] as number    );
}

export function useGetAssignmentCommentsQuery<TSelectData = Types.PagedResultOfCommentDto, TError = unknown>(dto: GetAssignmentCommentsCommentQueryParameters, options?: Omit<UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Retrieves all Comments of the specified Assignment.
 */
export function useGetAssignmentCommentsQuery<TSelectData = Types.PagedResultOfCommentDto, TError = unknown>(assignmentId: number, options?: Omit<UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetAssignmentCommentsQuery<TSelectData = Types.PagedResultOfCommentDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let assignmentId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ assignmentId,  } = params[0] as GetAssignmentCommentsCommentQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [assignmentId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PagedResultOfCommentDto, TError, TSelectData>({
    queryFn: __getAssignmentComments,
    queryKey: getAssignmentCommentsQueryKey(assignmentId),
    ...getAssignmentCommentsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Retrieves all Comments of the specified Assignment.
 */
export function setGetAssignmentCommentsData(queryClient: QueryClient, updater: (data: Types.PagedResultOfCommentDto | undefined) => Types.PagedResultOfCommentDto, assignmentId: number) {
  queryClient.setQueryData(getAssignmentCommentsQueryKey(assignmentId),
    updater
  );
}

/**
 * Retrieves all Comments of the specified Assignment.
 */
export function setGetAssignmentCommentsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedResultOfCommentDto | undefined) => Types.PagedResultOfCommentDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function addCommentToAssignmentUrl(assignmentId: number): string {
  let url_ = getBaseUrl() + "/api/assignments/{assignmentId}/comments";
if (assignmentId === undefined || assignmentId === null)
  throw new Error("The parameter 'assignmentId' must be defined.");
url_ = url_.replace("{assignmentId}", encodeURIComponent("" + assignmentId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function addCommentToAssignmentMutationKey(assignmentId: number): MutationKey {
  return trimArrayEnd([
      'CommentClient',
      'addCommentToAssignment',
      assignmentId as any,
    ]);
}

/**
 * Adds a Comment to the specified Assignment.
 */
export function useAddCommentToAssignmentMutation<TContext>(assignmentId: number, options?: Omit<UseMutationOptions<Types.CommentDto, unknown, Types.CreateCommentDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CommentDto, unknown, Types.CreateCommentDto, TContext> {
  const key = addCommentToAssignmentMutationKey(assignmentId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (createCommentDto: Types.CreateCommentDto) => Client.addCommentToAssignment(assignmentId, createCommentDto),
    mutationKey: key,
  });
}
  
type AddCommentToAssignment__MutationParameters = AddCommentToAssignmentCommentQueryParameters & {
  createCommentDto: Types.CreateCommentDto;
}

/**
 * Adds a Comment to the specified Assignment.
 */
export function useAddCommentToAssignmentMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CommentDto, unknown, AddCommentToAssignment__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AddCommentToAssignmentCommentQueryParameters}): UseMutationResult<Types.CommentDto, unknown, AddCommentToAssignment__MutationParameters, TContext> {
  const key = addCommentToAssignmentMutationKey(options?.parameters?.assignmentId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: AddCommentToAssignment__MutationParameters) => Client.addCommentToAssignment(data.assignmentId ?? options?.parameters?.assignmentId!, data.createCommentDto),
  mutationKey: key,
});
}
  
export function getPublicationCommentsUrl(publicationId: number): string {
  let url_ = getBaseUrl() + "/api/publication/{publicationId}/comments";
if (publicationId === undefined || publicationId === null)
  throw new Error("The parameter 'publicationId' must be defined.");
url_ = url_.replace("{publicationId}", encodeURIComponent("" + publicationId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPublicationCommentsDefaultOptions: Omit<UseQueryOptions<Types.PagedResultOfCommentDto, unknown, Types.PagedResultOfCommentDto>, 'queryKey'> = {
  queryFn: __getPublicationComments,
};
export function getGetPublicationCommentsDefaultOptions() {
  return getPublicationCommentsDefaultOptions;
};
export function setGetPublicationCommentsDefaultOptions(options: typeof getPublicationCommentsDefaultOptions) {
  getPublicationCommentsDefaultOptions = options;
}

export function getPublicationCommentsQueryKey(publicationId: number): QueryKey;
export function getPublicationCommentsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { publicationId,  } = params[0] as GetPublicationCommentsCommentQueryParameters;

    return trimArrayEnd([
        'CommentClient',
        'getPublicationComments',
        publicationId as any,
      ]);
  } else {
    return trimArrayEnd([
        'CommentClient',
        'getPublicationComments',
        ...params
      ]);
  }
}
function __getPublicationComments(context: QueryFunctionContext) {
  return Client.getPublicationComments(
      context.queryKey[2] as number    );
}

export function useGetPublicationCommentsQuery<TSelectData = Types.PagedResultOfCommentDto, TError = unknown>(dto: GetPublicationCommentsCommentQueryParameters, options?: Omit<UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Retrieves all Comments of the specified Publication.
 */
export function useGetPublicationCommentsQuery<TSelectData = Types.PagedResultOfCommentDto, TError = unknown>(publicationId: number, options?: Omit<UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetPublicationCommentsQuery<TSelectData = Types.PagedResultOfCommentDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let publicationId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ publicationId,  } = params[0] as GetPublicationCommentsCommentQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [publicationId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PagedResultOfCommentDto, TError, TSelectData>({
    queryFn: __getPublicationComments,
    queryKey: getPublicationCommentsQueryKey(publicationId),
    ...getPublicationCommentsDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedResultOfCommentDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Retrieves all Comments of the specified Publication.
 */
export function setGetPublicationCommentsData(queryClient: QueryClient, updater: (data: Types.PagedResultOfCommentDto | undefined) => Types.PagedResultOfCommentDto, publicationId: number) {
  queryClient.setQueryData(getPublicationCommentsQueryKey(publicationId),
    updater
  );
}

/**
 * Retrieves all Comments of the specified Publication.
 */
export function setGetPublicationCommentsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedResultOfCommentDto | undefined) => Types.PagedResultOfCommentDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function addCommentToPublicationUrl(publicationId: number): string {
  let url_ = getBaseUrl() + "/api/publication/{publicationId}/comments";
if (publicationId === undefined || publicationId === null)
  throw new Error("The parameter 'publicationId' must be defined.");
url_ = url_.replace("{publicationId}", encodeURIComponent("" + publicationId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function addCommentToPublicationMutationKey(publicationId: number): MutationKey {
  return trimArrayEnd([
      'CommentClient',
      'addCommentToPublication',
      publicationId as any,
    ]);
}

/**
 * Adds a Comment to the specified Publication.
 */
export function useAddCommentToPublicationMutation<TContext>(publicationId: number, options?: Omit<UseMutationOptions<Types.CommentDto, unknown, Types.CreateCommentDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CommentDto, unknown, Types.CreateCommentDto, TContext> {
  const key = addCommentToPublicationMutationKey(publicationId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (createCommentDto: Types.CreateCommentDto) => Client.addCommentToPublication(publicationId, createCommentDto),
    mutationKey: key,
  });
}
  
type AddCommentToPublication__MutationParameters = AddCommentToPublicationCommentQueryParameters & {
  createCommentDto: Types.CreateCommentDto;
}

/**
 * Adds a Comment to the specified Publication.
 */
export function useAddCommentToPublicationMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CommentDto, unknown, AddCommentToPublication__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: AddCommentToPublicationCommentQueryParameters}): UseMutationResult<Types.CommentDto, unknown, AddCommentToPublication__MutationParameters, TContext> {
  const key = addCommentToPublicationMutationKey(options?.parameters?.publicationId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: AddCommentToPublication__MutationParameters) => Client.addCommentToPublication(data.publicationId ?? options?.parameters?.publicationId!, data.createCommentDto),
  mutationKey: key,
});
}
  
export function editCommentUrl(commentId: number): string {
  let url_ = getBaseUrl() + "/api/comments/{commentId}";
if (commentId === undefined || commentId === null)
  throw new Error("The parameter 'commentId' must be defined.");
url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function editCommentMutationKey(commentId: number): MutationKey {
  return trimArrayEnd([
      'CommentClient',
      'editComment',
      commentId as any,
    ]);
}

/**
 * Edits a Comment. Only the author of the comment or an admin can edit a comment.
 */
export function useEditCommentMutation<TContext>(commentId: number, options?: Omit<UseMutationOptions<void, unknown, Types.PatchCommentDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.PatchCommentDto, TContext> {
  const key = editCommentMutationKey(commentId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (patchCommentDto: Types.PatchCommentDto) => Client.editComment(commentId, patchCommentDto),
    mutationKey: key,
  });
}
  
type EditComment__MutationParameters = EditCommentCommentQueryParameters & {
  patchCommentDto: Types.PatchCommentDto;
}

/**
 * Edits a Comment. Only the author of the comment or an admin can edit a comment.
 */
export function useEditCommentMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, EditComment__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: EditCommentCommentQueryParameters}): UseMutationResult<void, unknown, EditComment__MutationParameters, TContext> {
  const key = editCommentMutationKey(options?.parameters?.commentId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: EditComment__MutationParameters) => Client.editComment(data.commentId ?? options?.parameters?.commentId!, data.patchCommentDto),
  mutationKey: key,
});
}
  
export function deleteCommentUrl(commentId: number): string {
  let url_ = getBaseUrl() + "/api/comments/{commentId}";
if (commentId === undefined || commentId === null)
  throw new Error("The parameter 'commentId' must be defined.");
url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteCommentMutationKey(commentId: number): MutationKey {
  return trimArrayEnd([
      'CommentClient',
      'deleteComment',
      commentId as any,
    ]);
}

/**
 * Deletes a Comment.
Only the author of the comment or an admin can delete a comment.
 */
export function useDeleteCommentMutation<TContext>(commentId: number, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteCommentMutationKey(commentId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.deleteComment(commentId),
    mutationKey: key,
  });
}
  
type DeleteComment__MutationParameters = DeleteCommentCommentQueryParameters

/**
 * Deletes a Comment.
Only the author of the comment or an admin can delete a comment.
 */
export function useDeleteCommentMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteComment__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteCommentCommentQueryParameters}): UseMutationResult<void, unknown, DeleteComment__MutationParameters, TContext> {
  const key = deleteCommentMutationKey(options?.parameters?.commentId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteComment__MutationParameters) => Client.deleteComment(data.commentId ?? options?.parameters?.commentId!),
  mutationKey: key,
});
}