//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client.types';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../api-client.types';
import { getAxios, getBaseUrl } from './helpers';

/**
 * Returns all courses. Admin only.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function getCourses(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PagedResultOfCourseListItemDto> {
    let url_ = getBaseUrl() + "/api/courses?";
    if (title !== undefined && title !== null)
        url_ += "Title=" + encodeURIComponent("" + title) + "&";
    if (createdByMe !== undefined && createdByMe !== null)
        url_ += "CreatedByMe=" + encodeURIComponent("" + createdByMe) + "&";
    if (whereImTeacher !== undefined && whereImTeacher !== null)
        url_ += "WhereImTeacher=" + encodeURIComponent("" + whereImTeacher) + "&";
    if (whereImStudent !== undefined && whereImStudent !== null)
        url_ += "WhereImStudent=" + encodeURIComponent("" + whereImStudent) + "&";
    if (offset !== undefined && offset !== null)
        url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
    if (limit !== undefined && limit !== null)
        url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
    if (sortBy !== undefined && sortBy !== null)
        url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
    if (sortOrder === null)
        throw new Error("The parameter 'sortOrder' cannot be null.");
    else if (sortOrder !== undefined)
        url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetCourses,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetCourses?.headers,
            "Accept": "application/json"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetCourses(_response);
    });
}

function processGetCourses(response: AxiosResponse): Promise<Types.PagedResultOfCourseListItemDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initValidationProblemDetails(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPagedResultOfCourseListItemDto(resultData200);
        return Promise.resolve<Types.PagedResultOfCourseListItemDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PagedResultOfCourseListItemDto>(null as any);
}

/**
 * Creates a new course. Only teachers can create courses.
 */
export function createCourse(courseDto: Types.CreateCourseDto, config?: AxiosRequestConfig | undefined): Promise<Types.CourseDto> {
    let url_ = getBaseUrl() + "/api/courses";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializeCreateCourseDto(courseDto);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreateCourse,
        ...config,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            ..._requestConfigCreateCourse?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreateCourse(_response);
    });
}

function processCreateCourse(response: AxiosResponse): Promise<Types.CourseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initValidationProblemDetails(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initCourseDto(resultData200);
        return Promise.resolve<Types.CourseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CourseDto>(null as any);
}

/**
 * Returns all courses the user is enrolled in or is teaching in.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function getMyCourses(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined, config?: AxiosRequestConfig | undefined): Promise<Types.PagedResultOfCourseListItemDto> {
    let url_ = getBaseUrl() + "/api/courses/my?";
    if (title !== undefined && title !== null)
        url_ += "Title=" + encodeURIComponent("" + title) + "&";
    if (createdByMe !== undefined && createdByMe !== null)
        url_ += "CreatedByMe=" + encodeURIComponent("" + createdByMe) + "&";
    if (whereImTeacher !== undefined && whereImTeacher !== null)
        url_ += "WhereImTeacher=" + encodeURIComponent("" + whereImTeacher) + "&";
    if (whereImStudent !== undefined && whereImStudent !== null)
        url_ += "WhereImStudent=" + encodeURIComponent("" + whereImStudent) + "&";
    if (offset !== undefined && offset !== null)
        url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
    if (limit !== undefined && limit !== null)
        url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
    if (sortBy !== undefined && sortBy !== null)
        url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
    if (sortOrder === null)
        throw new Error("The parameter 'sortOrder' cannot be null.");
    else if (sortOrder !== undefined)
        url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetMyCourses,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetMyCourses?.headers,
            "Accept": "application/json"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetMyCourses(_response);
    });
}

function processGetMyCourses(response: AxiosResponse): Promise<Types.PagedResultOfCourseListItemDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initValidationProblemDetails(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPagedResultOfCourseListItemDto(resultData200);
        return Promise.resolve<Types.PagedResultOfCourseListItemDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PagedResultOfCourseListItemDto>(null as any);
}

/**
 * Returns a course by its ID.
The user must be enrolled in the course or be teaching in it to access this endpoint.
 */
export function getCourse(courseId: number, config?: AxiosRequestConfig | undefined): Promise<Types.CourseDto> {
    let url_ = getBaseUrl() + "/api/courses/{courseId}";
    if (courseId === undefined || courseId === null)
      throw new Error("The parameter 'courseId' must be defined.");
    url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetCourse,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetCourse?.headers,
            "Accept": "application/json"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetCourse(_response);
    });
}

function processGetCourse(response: AxiosResponse): Promise<Types.CourseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initValidationProblemDetails(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initCourseDto(resultData200);
        return Promise.resolve<Types.CourseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CourseDto>(null as any);
}

/**
 * Updates a course. Only teachers of the course can update it.
 */
export function patchCourse(courseId: number, patchDto: Types.PatchCourseDto, config?: AxiosRequestConfig | undefined): Promise<Types.CourseDto> {
    let url_ = getBaseUrl() + "/api/courses/{courseId}";
    if (courseId === undefined || courseId === null)
      throw new Error("The parameter 'courseId' must be defined.");
    url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = Types.serializePatchCourseDto(patchDto);

    let options_: AxiosRequestConfig = {
        ..._requestConfigPatchCourse,
        ...config,
        data: content_,
        method: "PATCH",
        url: url_,
        headers: {
            ..._requestConfigPatchCourse?.headers,
            "Content-Type": "application/json",
            "Accept": "application/json"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPatchCourse(_response);
    });
}

function processPatchCourse(response: AxiosResponse): Promise<Types.CourseDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initValidationProblemDetails(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initCourseDto(resultData200);
        return Promise.resolve<Types.CourseDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.CourseDto>(null as any);
}

/**
 * Deletes a course. Only teachers of the course can delete it.
 */
export function deleteCourse(courseId: number, config?: AxiosRequestConfig | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/api/courses/{courseId}";
    if (courseId === undefined || courseId === null)
      throw new Error("The parameter 'courseId' must be defined.");
    url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeleteCourse,
        ...config,
        method: "DELETE",
        url: url_,
        headers: {
            ..._requestConfigDeleteCourse?.headers,
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeleteCourse(_response);
    });
}

function processDeleteCourse(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initValidationProblemDetails(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Returns all members of a course.
The user must be teaching in it to access this endpoint.
 */
export function getCourseMembers(courseId: number, config?: AxiosRequestConfig | undefined): Promise<Types.PagedResultOfCourseMemberDto> {
    let url_ = getBaseUrl() + "/api/courses/{courseId}/members";
    if (courseId === undefined || courseId === null)
      throw new Error("The parameter 'courseId' must be defined.");
    url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetCourseMembers,
        ...config,
        method: "GET",
        url: url_,
        headers: {
            ..._requestConfigGetCourseMembers?.headers,
            "Accept": "application/json"
        }
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetCourseMembers(_response);
    });
}

function processGetCourseMembers(response: AxiosResponse): Promise<Types.PagedResultOfCourseMemberDto> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        let result400: any = null;
        let resultData400  = _responseText;
        result400 = Types.initValidationProblemDetails(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);

    } else if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.initPagedResultOfCourseMemberDto(resultData200);
        return Promise.resolve<Types.PagedResultOfCourseMemberDto>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.PagedResultOfCourseMemberDto>(null as any);
}
let _requestConfigGetCourses: Partial<AxiosRequestConfig> | null;
export function getGetCoursesRequestConfig() {
  return _requestConfigGetCourses;
}
export function setGetCoursesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetCourses = value;
}
export function patchGetCoursesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetCourses = patch(_requestConfigGetCourses ?? {});
}

let _requestConfigCreateCourse: Partial<AxiosRequestConfig> | null;
export function getCreateCourseRequestConfig() {
  return _requestConfigCreateCourse;
}
export function setCreateCourseRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreateCourse = value;
}
export function patchCreateCourseRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreateCourse = patch(_requestConfigCreateCourse ?? {});
}

let _requestConfigGetMyCourses: Partial<AxiosRequestConfig> | null;
export function getGetMyCoursesRequestConfig() {
  return _requestConfigGetMyCourses;
}
export function setGetMyCoursesRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetMyCourses = value;
}
export function patchGetMyCoursesRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetMyCourses = patch(_requestConfigGetMyCourses ?? {});
}

let _requestConfigGetCourse: Partial<AxiosRequestConfig> | null;
export function getGetCourseRequestConfig() {
  return _requestConfigGetCourse;
}
export function setGetCourseRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetCourse = value;
}
export function patchGetCourseRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetCourse = patch(_requestConfigGetCourse ?? {});
}

let _requestConfigPatchCourse: Partial<AxiosRequestConfig> | null;
export function getPatchCourseRequestConfig() {
  return _requestConfigPatchCourse;
}
export function setPatchCourseRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPatchCourse = value;
}
export function patchPatchCourseRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPatchCourse = patch(_requestConfigPatchCourse ?? {});
}

let _requestConfigDeleteCourse: Partial<AxiosRequestConfig> | null;
export function getDeleteCourseRequestConfig() {
  return _requestConfigDeleteCourse;
}
export function setDeleteCourseRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeleteCourse = value;
}
export function patchDeleteCourseRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeleteCourse = patch(_requestConfigDeleteCourse ?? {});
}

let _requestConfigGetCourseMembers: Partial<AxiosRequestConfig> | null;
export function getGetCourseMembersRequestConfig() {
  return _requestConfigGetCourseMembers;
}
export function setGetCourseMembersRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetCourseMembers = value;
}
export function patchGetCourseMembersRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetCourseMembers = patch(_requestConfigGetCourseMembers ?? {});
}