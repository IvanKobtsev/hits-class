//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../api-client.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './CourseClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type GetCoursesCourseQueryParameters = {
  title?: string | null | undefined ;
  createdByMe?: boolean | null | undefined ;
  whereImTeacher?: boolean | null | undefined ;
  whereImStudent?: boolean | null | undefined ;
  offset?: number | null | undefined ;
  limit?: number | null | undefined ;
  sortBy?: string | null | undefined ;
  sortOrder?: Types.SortOrder | undefined ;
}

export type GetMyCoursesCourseQueryParameters = {
  title?: string | null | undefined ;
  createdByMe?: boolean | null | undefined ;
  whereImTeacher?: boolean | null | undefined ;
  whereImStudent?: boolean | null | undefined ;
  offset?: number | null | undefined ;
  limit?: number | null | undefined ;
  sortBy?: string | null | undefined ;
  sortOrder?: Types.SortOrder | undefined ;
}

export type GetCourseCourseQueryParameters = {
  courseId: number ;
}

export type PatchCourseCourseQueryParameters = {
  courseId: number ;
}

export type DeleteCourseCourseQueryParameters = {
  courseId: number ;
}

export type GetCourseMembersCourseQueryParameters = {
  courseId: number ;
}

export function getCoursesUrl(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined): string {
  let url_ = getBaseUrl() + "/api/courses?";
if (title !== undefined && title !== null)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (createdByMe !== undefined && createdByMe !== null)
    url_ += "CreatedByMe=" + encodeURIComponent("" + createdByMe) + "&";
if (whereImTeacher !== undefined && whereImTeacher !== null)
    url_ += "WhereImTeacher=" + encodeURIComponent("" + whereImTeacher) + "&";
if (whereImStudent !== undefined && whereImStudent !== null)
    url_ += "WhereImStudent=" + encodeURIComponent("" + whereImStudent) + "&";
if (offset !== undefined && offset !== null)
    url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
if (limit !== undefined && limit !== null)
    url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
if (sortOrder === null)
    throw new Error("The parameter 'sortOrder' cannot be null.");
else if (sortOrder !== undefined)
    url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getCoursesDefaultOptions: Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, unknown, Types.PagedResultOfCourseListItemDto>, 'queryKey'> = {
  queryFn: __getCourses,
};
export function getGetCoursesDefaultOptions() {
  return getCoursesDefaultOptions;
};
export function setGetCoursesDefaultOptions(options: typeof getCoursesDefaultOptions) {
  getCoursesDefaultOptions = options;
}

export function getCoursesQueryKey(dto: GetCoursesCourseQueryParameters): QueryKey;
export function getCoursesQueryKey(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined): QueryKey;
export function getCoursesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder,  } = params[0] as GetCoursesCourseQueryParameters;

    return trimArrayEnd([
        'CourseClient',
        'getCourses',
        title as any,
        createdByMe as any,
        whereImTeacher as any,
        whereImStudent as any,
        offset as any,
        limit as any,
        sortBy as any,
        sortOrder as any,
      ]);
  } else {
    return trimArrayEnd([
        'CourseClient',
        'getCourses',
        ...params
      ]);
  }
}
function __getCourses(context: QueryFunctionContext) {
  return Client.getCourses(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as boolean | null | undefined,       context.queryKey[4] as boolean | null | undefined,       context.queryKey[5] as boolean | null | undefined,       context.queryKey[6] as number | null | undefined,       context.queryKey[7] as number | null | undefined,       context.queryKey[8] as string | null | undefined,       context.queryKey[9] as Types.SortOrder | undefined    );
}

export function useGetCoursesQuery<TSelectData = Types.PagedResultOfCourseListItemDto, TError = unknown>(dto: GetCoursesCourseQueryParameters, options?: Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Returns all courses. Admin only.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function useGetCoursesQuery<TSelectData = Types.PagedResultOfCourseListItemDto, TError = unknown>(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined, options?: Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetCoursesQuery<TSelectData = Types.PagedResultOfCourseListItemDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let title: any = undefined;
  let createdByMe: any = undefined;
  let whereImTeacher: any = undefined;
  let whereImStudent: any = undefined;
  let offset: any = undefined;
  let limit: any = undefined;
  let sortBy: any = undefined;
  let sortOrder: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder,  } = params[0] as GetCoursesCourseQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PagedResultOfCourseListItemDto, TError, TSelectData>({
    queryFn: __getCourses,
    queryKey: getCoursesQueryKey(title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder),
    ...getCoursesDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Returns all courses. Admin only.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function setGetCoursesData(queryClient: QueryClient, updater: (data: Types.PagedResultOfCourseListItemDto | undefined) => Types.PagedResultOfCourseListItemDto, title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined) {
  queryClient.setQueryData(getCoursesQueryKey(title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder),
    updater
  );
}

/**
 * Returns all courses. Admin only.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function setGetCoursesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedResultOfCourseListItemDto | undefined) => Types.PagedResultOfCourseListItemDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createCourseUrl(): string {
  let url_ = getBaseUrl() + "/api/courses";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createCourseMutationKey(): MutationKey {
  return trimArrayEnd([
      'CourseClient',
      'createCourse',
    ]);
}

/**
 * Creates a new course. Only teachers can create courses.
 */
export function useCreateCourseMutation<TContext>(options?: Omit<UseMutationOptions<Types.CourseDto, unknown, Types.CreateCourseDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CourseDto, unknown, Types.CreateCourseDto, TContext> {
  const key = createCourseMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (courseDto: Types.CreateCourseDto) => Client.createCourse(courseDto),
    mutationKey: key,
  });
}
  
export function getMyCoursesUrl(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined): string {
  let url_ = getBaseUrl() + "/api/courses/my?";
if (title !== undefined && title !== null)
    url_ += "Title=" + encodeURIComponent("" + title) + "&";
if (createdByMe !== undefined && createdByMe !== null)
    url_ += "CreatedByMe=" + encodeURIComponent("" + createdByMe) + "&";
if (whereImTeacher !== undefined && whereImTeacher !== null)
    url_ += "WhereImTeacher=" + encodeURIComponent("" + whereImTeacher) + "&";
if (whereImStudent !== undefined && whereImStudent !== null)
    url_ += "WhereImStudent=" + encodeURIComponent("" + whereImStudent) + "&";
if (offset !== undefined && offset !== null)
    url_ += "Offset=" + encodeURIComponent("" + offset) + "&";
if (limit !== undefined && limit !== null)
    url_ += "Limit=" + encodeURIComponent("" + limit) + "&";
if (sortBy !== undefined && sortBy !== null)
    url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
if (sortOrder === null)
    throw new Error("The parameter 'sortOrder' cannot be null.");
else if (sortOrder !== undefined)
    url_ += "SortOrder=" + encodeURIComponent("" + sortOrder) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getMyCoursesDefaultOptions: Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, unknown, Types.PagedResultOfCourseListItemDto>, 'queryKey'> = {
  queryFn: __getMyCourses,
};
export function getGetMyCoursesDefaultOptions() {
  return getMyCoursesDefaultOptions;
};
export function setGetMyCoursesDefaultOptions(options: typeof getMyCoursesDefaultOptions) {
  getMyCoursesDefaultOptions = options;
}

export function getMyCoursesQueryKey(dto: GetMyCoursesCourseQueryParameters): QueryKey;
export function getMyCoursesQueryKey(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined): QueryKey;
export function getMyCoursesQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder,  } = params[0] as GetMyCoursesCourseQueryParameters;

    return trimArrayEnd([
        'CourseClient',
        'getMyCourses',
        title as any,
        createdByMe as any,
        whereImTeacher as any,
        whereImStudent as any,
        offset as any,
        limit as any,
        sortBy as any,
        sortOrder as any,
      ]);
  } else {
    return trimArrayEnd([
        'CourseClient',
        'getMyCourses',
        ...params
      ]);
  }
}
function __getMyCourses(context: QueryFunctionContext) {
  return Client.getMyCourses(
      context.queryKey[2] as string | null | undefined,       context.queryKey[3] as boolean | null | undefined,       context.queryKey[4] as boolean | null | undefined,       context.queryKey[5] as boolean | null | undefined,       context.queryKey[6] as number | null | undefined,       context.queryKey[7] as number | null | undefined,       context.queryKey[8] as string | null | undefined,       context.queryKey[9] as Types.SortOrder | undefined    );
}

export function useGetMyCoursesQuery<TSelectData = Types.PagedResultOfCourseListItemDto, TError = unknown>(dto: GetMyCoursesCourseQueryParameters, options?: Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Returns all courses the user is enrolled in or is teaching in.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function useGetMyCoursesQuery<TSelectData = Types.PagedResultOfCourseListItemDto, TError = unknown>(title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined, options?: Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetMyCoursesQuery<TSelectData = Types.PagedResultOfCourseListItemDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let title: any = undefined;
  let createdByMe: any = undefined;
  let whereImTeacher: any = undefined;
  let whereImStudent: any = undefined;
  let offset: any = undefined;
  let limit: any = undefined;
  let sortBy: any = undefined;
  let sortOrder: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder,  } = params[0] as GetMyCoursesCourseQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PagedResultOfCourseListItemDto, TError, TSelectData>({
    queryFn: __getMyCourses,
    queryKey: getMyCoursesQueryKey(title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder),
    ...getMyCoursesDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedResultOfCourseListItemDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Returns all courses the user is enrolled in or is teaching in.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function setGetMyCoursesData(queryClient: QueryClient, updater: (data: Types.PagedResultOfCourseListItemDto | undefined) => Types.PagedResultOfCourseListItemDto, title?: string | null | undefined, createdByMe?: boolean | null | undefined, whereImTeacher?: boolean | null | undefined, whereImStudent?: boolean | null | undefined, offset?: number | null | undefined, limit?: number | null | undefined, sortBy?: string | null | undefined, sortOrder?: Types.SortOrder | undefined) {
  queryClient.setQueryData(getMyCoursesQueryKey(title, createdByMe, whereImTeacher, whereImStudent, offset, limit, sortBy, sortOrder),
    updater
  );
}

/**
 * Returns all courses the user is enrolled in or is teaching in.
 * @param title (optional) 
 * @param createdByMe (optional) 
 * @param whereImTeacher (optional) 
 * @param whereImStudent (optional) 
 * @param offset (optional) Offset of list.
 * @param limit (optional) Number of requested records.
 * @param sortBy (optional) Field name for sorting in DB.
 * @param sortOrder (optional) Sort direction. Ascending or Descending.
 */
export function setGetMyCoursesDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedResultOfCourseListItemDto | undefined) => Types.PagedResultOfCourseListItemDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getCourseUrl(courseId: number): string {
  let url_ = getBaseUrl() + "/api/courses/{courseId}";
if (courseId === undefined || courseId === null)
  throw new Error("The parameter 'courseId' must be defined.");
url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getCourseDefaultOptions: Omit<UseQueryOptions<Types.CourseDto, unknown, Types.CourseDto>, 'queryKey'> = {
  queryFn: __getCourse,
};
export function getGetCourseDefaultOptions() {
  return getCourseDefaultOptions;
};
export function setGetCourseDefaultOptions(options: typeof getCourseDefaultOptions) {
  getCourseDefaultOptions = options;
}

export function getCourseQueryKey(courseId: number): QueryKey;
export function getCourseQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { courseId,  } = params[0] as GetCourseCourseQueryParameters;

    return trimArrayEnd([
        'CourseClient',
        'getCourse',
        courseId as any,
      ]);
  } else {
    return trimArrayEnd([
        'CourseClient',
        'getCourse',
        ...params
      ]);
  }
}
function __getCourse(context: QueryFunctionContext) {
  return Client.getCourse(
      context.queryKey[2] as number    );
}

export function useGetCourseQuery<TSelectData = Types.CourseDto, TError = unknown>(dto: GetCourseCourseQueryParameters, options?: Omit<UseQueryOptions<Types.CourseDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Returns a course by its ID.
The user must be enrolled in the course or be teaching in it to access this endpoint.
 */
export function useGetCourseQuery<TSelectData = Types.CourseDto, TError = unknown>(courseId: number, options?: Omit<UseQueryOptions<Types.CourseDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetCourseQuery<TSelectData = Types.CourseDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.CourseDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let courseId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ courseId,  } = params[0] as GetCourseCourseQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [courseId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.CourseDto, TError, TSelectData>({
    queryFn: __getCourse,
    queryKey: getCourseQueryKey(courseId),
    ...getCourseDefaultOptions as unknown as Omit<UseQueryOptions<Types.CourseDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Returns a course by its ID.
The user must be enrolled in the course or be teaching in it to access this endpoint.
 */
export function setGetCourseData(queryClient: QueryClient, updater: (data: Types.CourseDto | undefined) => Types.CourseDto, courseId: number) {
  queryClient.setQueryData(getCourseQueryKey(courseId),
    updater
  );
}

/**
 * Returns a course by its ID.
The user must be enrolled in the course or be teaching in it to access this endpoint.
 */
export function setGetCourseDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.CourseDto | undefined) => Types.CourseDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function patchCourseUrl(courseId: number): string {
  let url_ = getBaseUrl() + "/api/courses/{courseId}";
if (courseId === undefined || courseId === null)
  throw new Error("The parameter 'courseId' must be defined.");
url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function patchCourseMutationKey(courseId: number): MutationKey {
  return trimArrayEnd([
      'CourseClient',
      'patchCourse',
      courseId as any,
    ]);
}

/**
 * Updates a course. Only teachers of the course can update it.
 */
export function usePatchCourseMutation<TContext>(courseId: number, options?: Omit<UseMutationOptions<Types.CourseDto, unknown, Types.PatchCourseDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.CourseDto, unknown, Types.PatchCourseDto, TContext> {
  const key = patchCourseMutationKey(courseId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (patchDto: Types.PatchCourseDto) => Client.patchCourse(courseId, patchDto),
    mutationKey: key,
  });
}
  
type PatchCourse__MutationParameters = PatchCourseCourseQueryParameters & {
  patchDto: Types.PatchCourseDto;
}

/**
 * Updates a course. Only teachers of the course can update it.
 */
export function usePatchCourseMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.CourseDto, unknown, PatchCourse__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: PatchCourseCourseQueryParameters}): UseMutationResult<Types.CourseDto, unknown, PatchCourse__MutationParameters, TContext> {
  const key = patchCourseMutationKey(options?.parameters?.courseId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: PatchCourse__MutationParameters) => Client.patchCourse(data.courseId ?? options?.parameters?.courseId!, data.patchDto),
  mutationKey: key,
});
}
  
export function deleteCourseUrl(courseId: number): string {
  let url_ = getBaseUrl() + "/api/courses/{courseId}";
if (courseId === undefined || courseId === null)
  throw new Error("The parameter 'courseId' must be defined.");
url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteCourseMutationKey(courseId: number): MutationKey {
  return trimArrayEnd([
      'CourseClient',
      'deleteCourse',
      courseId as any,
    ]);
}

/**
 * Deletes a course. Only teachers of the course can delete it.
 */
export function useDeleteCourseMutation<TContext>(courseId: number, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteCourseMutationKey(courseId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client.deleteCourse(courseId),
    mutationKey: key,
  });
}
  
type DeleteCourse__MutationParameters = DeleteCourseCourseQueryParameters

/**
 * Deletes a course. Only teachers of the course can delete it.
 */
export function useDeleteCourseMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteCourse__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteCourseCourseQueryParameters}): UseMutationResult<void, unknown, DeleteCourse__MutationParameters, TContext> {
  const key = deleteCourseMutationKey(options?.parameters?.courseId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteCourse__MutationParameters) => Client.deleteCourse(data.courseId ?? options?.parameters?.courseId!),
  mutationKey: key,
});
}
  
export function getCourseMembersUrl(courseId: number): string {
  let url_ = getBaseUrl() + "/api/courses/{courseId}/members";
if (courseId === undefined || courseId === null)
  throw new Error("The parameter 'courseId' must be defined.");
url_ = url_.replace("{courseId}", encodeURIComponent("" + courseId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getCourseMembersDefaultOptions: Omit<UseQueryOptions<Types.PagedResultOfCourseMemberDto, unknown, Types.PagedResultOfCourseMemberDto>, 'queryKey'> = {
  queryFn: __getCourseMembers,
};
export function getGetCourseMembersDefaultOptions() {
  return getCourseMembersDefaultOptions;
};
export function setGetCourseMembersDefaultOptions(options: typeof getCourseMembersDefaultOptions) {
  getCourseMembersDefaultOptions = options;
}

export function getCourseMembersQueryKey(courseId: number): QueryKey;
export function getCourseMembersQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { courseId,  } = params[0] as GetCourseMembersCourseQueryParameters;

    return trimArrayEnd([
        'CourseClient',
        'getCourseMembers',
        courseId as any,
      ]);
  } else {
    return trimArrayEnd([
        'CourseClient',
        'getCourseMembers',
        ...params
      ]);
  }
}
function __getCourseMembers(context: QueryFunctionContext) {
  return Client.getCourseMembers(
      context.queryKey[2] as number    );
}

export function useGetCourseMembersQuery<TSelectData = Types.PagedResultOfCourseMemberDto, TError = unknown>(dto: GetCourseMembersCourseQueryParameters, options?: Omit<UseQueryOptions<Types.PagedResultOfCourseMemberDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Returns all members of a course.
The user must be teaching in it to access this endpoint.
 */
export function useGetCourseMembersQuery<TSelectData = Types.PagedResultOfCourseMemberDto, TError = unknown>(courseId: number, options?: Omit<UseQueryOptions<Types.PagedResultOfCourseMemberDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetCourseMembersQuery<TSelectData = Types.PagedResultOfCourseMemberDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.PagedResultOfCourseMemberDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let courseId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ courseId,  } = params[0] as GetCourseMembersCourseQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [courseId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.PagedResultOfCourseMemberDto, TError, TSelectData>({
    queryFn: __getCourseMembers,
    queryKey: getCourseMembersQueryKey(courseId),
    ...getCourseMembersDefaultOptions as unknown as Omit<UseQueryOptions<Types.PagedResultOfCourseMemberDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Returns all members of a course.
The user must be teaching in it to access this endpoint.
 */
export function setGetCourseMembersData(queryClient: QueryClient, updater: (data: Types.PagedResultOfCourseMemberDto | undefined) => Types.PagedResultOfCourseMemberDto, courseId: number) {
  queryClient.setQueryData(getCourseMembersQueryKey(courseId),
    updater
  );
}

/**
 * Returns all members of a course.
The user must be teaching in it to access this endpoint.
 */
export function setGetCourseMembersDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.PagedResultOfCourseMemberDto | undefined) => Types.PagedResultOfCourseMemberDto) {
  queryClient.setQueryData(queryKey, updater);
}